1
00:00:00,000 --> 00:00:06,240
Probabilmente anche tu come me all'inizio di quest'anno avrai sentito parlare del ragazzo

2
00:00:06,240 --> 00:00:12,360
di 13 anni che per primo ha completato il mitico videogioco chiamato Tetris, la notizia

3
00:00:12,360 --> 00:00:16,520
era un po' dovunque sul web ed è stata perfino al telegiornale.

4
00:00:16,520 --> 00:00:23,280
Quando ne ho letto ho deciso così, per curiosità, di andarmi a guardare il momento della vittoria

5
00:00:23,280 --> 00:00:29,400
recuperando la registrazione della diretta streaming su YouTube e saltando un po' lungo

6
00:00:29,400 --> 00:00:35,880
la timeline del video ho notato che in sottofondo si può sentire un suono che si ripete di

7
00:00:35,880 --> 00:00:38,280
continuo, una sorta di tamburellio.

8
00:00:38,280 --> 00:00:43,600
Mi sono immediatamente chiesto cosa fosse quel rumore e indagando un po' ho scoperto

9
00:00:43,600 --> 00:00:48,720
una quantità di informazioni interessanti di cui onestamente non avevo idea, questo

10
00:00:48,720 --> 00:00:54,280
episodio è un po' il riassunto di tutto ciò che ho imparato quel giorno su Tetris.

11
00:00:54,280 --> 00:00:55,280
Sigla.

12
00:00:56,280 --> 00:01:04,280
Benvenuti su Pensieri in Codice, il podcast dove si ragiona da informatici, con Valerio Galano.

13
00:01:09,280 --> 00:01:16,440
Willis Gibson, di 13 anni, anche conosciuto come Blue Scooty, è stato ufficialmente riconosciuto

14
00:01:16,440 --> 00:01:22,560
come il primo essere umano ad aver completato il celebrrimo gioco Tetris per Nintendo, dopo

15
00:01:22,560 --> 00:01:25,400
ben 34 anni dalla sua pubblicazione.

16
00:01:25,400 --> 00:01:32,040
Il termine essere umano qui è d'obbligo perché prima d'ora l'impresa era stata realizzata

17
00:01:32,040 --> 00:01:38,400
da alcune intelligenze artificiali sviluppate ad hoc, ma Willis è stato il primo a riuscire

18
00:01:38,400 --> 00:01:42,400
con le proprie sole forze, almeno fra i casi documentati.

19
00:01:42,400 --> 00:01:49,120
Si tratta di un risultato a dir poco fenomenale e non solo per gli ostacoli implementati dagli

20
00:01:49,120 --> 00:01:55,400
sviluppatori come parte del gioco, ma anche per le tantissime anomalie che si presentano

21
00:01:55,400 --> 00:02:00,800
a poco a poco mentre si procede con una partita che si protrae a lungo nel tempo.

22
00:02:00,800 --> 00:02:06,720
Solo guardando il filmato di Willis, infatti, si notano già immediatamente tutta una serie

23
00:02:06,720 --> 00:02:07,720
di problemi.

24
00:02:07,720 --> 00:02:13,280
Il contatore del punteggio, ad esempio, raggiunge il massimo, cioè circa un milione, a livello

25
00:02:13,280 --> 00:02:19,320
27, quando il video è ancora a meno di un quarto del totale, e poco dopo, a partire

26
00:02:19,320 --> 00:02:24,280
dal livello 29, va in tilt anche il contatore dei livelli stessi, che inizia a mostrare

27
00:02:24,280 --> 00:02:26,760
numeri e lettere non più sequenziali.

28
00:02:26,760 --> 00:02:33,280
Ma, al di là di tutti questi dettagli, seppur interessanti, la domanda forse più ovvia,

29
00:02:33,280 --> 00:02:39,640
la prima che dovrebbe sorgere quasi immediatamente quando si pensa a come finire Tetris, è che

30
00:02:39,640 --> 00:02:42,520
cosa si intende per fine di Tetris?

31
00:02:42,760 --> 00:02:47,800
Se hai mai giocato una partita a questo gioco in vita tua, infatti, dovresti sapere che

32
00:02:47,800 --> 00:02:54,080
in effetti esso non ha una storia e non ha nemmeno una vera e propria fine definita dagli

33
00:02:54,080 --> 00:02:59,720
sviluppatori come un particolare livello o punteggio o l'atto di svuotare completamente

34
00:02:59,720 --> 00:03:00,720
il quadro.

35
00:03:00,720 --> 00:03:06,320
Probabilmente quando fu progettato e realizzato, almeno nella sua versione per console NES,

36
00:03:06,320 --> 00:03:12,020
che sta per Nintendo Entertainment System, nessuno si preoccupò o immaginò che qualcuno

37
00:03:12,020 --> 00:03:17,300
potesse raggiungere livelli tali di abilità da dover considerare la necessità di stabilire

38
00:03:17,300 --> 00:03:18,300
una fine.

39
00:03:18,300 --> 00:03:24,520
I tetramini, cioè i pezzi di varie forme da incastrare nel gioco, continuano semplicemente

40
00:03:24,520 --> 00:03:30,580
a cadere all'infinito e, per un giocatore inesperto, la fine arriva quando non è più

41
00:03:30,580 --> 00:03:36,940
in grado di piazzarli correttamente e lo schermo si riempie e la partita termina, game over.

42
00:03:36,980 --> 00:03:42,620
Tuttavia, per un giocatore molto esperto come Willis, la questione è completamente diversa.

43
00:03:47,620 --> 00:03:51,980
Il giovane Willis è dunque arrivato alla fine di Tetris, ma come ha fatto?

44
00:03:51,980 --> 00:03:57,940
Beh, devi sapere che per alcuni videogame pensati per procedere all'infinito, può esistere

45
00:03:57,940 --> 00:04:03,700
quello che viene definito il kill screen, in italiano potremmo dire la schermata di

46
00:04:03,700 --> 00:04:04,700
morte.

47
00:04:04,700 --> 00:04:10,020
Fondamentalmente si tratta di un punto del gioco in cui diventa letteralmente impossibile

48
00:04:10,020 --> 00:04:16,340
proseguire per via del fatto che si presenta un qualche tipo di problema o di bug che inficia

49
00:04:16,340 --> 00:04:18,020
il funzionamento del gioco stesso.

50
00:04:18,020 --> 00:04:25,180
Un esempio molto famoso di kill screen è il livello 256 di Pac-Man, che una volta raggiunto

51
00:04:25,180 --> 00:04:30,380
causa l'apparizione di caratteri e simboli casuali che riempiono metà dello schermo

52
00:04:30,380 --> 00:04:33,500
e rendono impossibile di fatto giocare oltre.

53
00:04:33,940 --> 00:04:39,620
Ma ad ogni modo, quale che sia il kill screen o il videogioco in questione, la fine è causata

54
00:04:39,620 --> 00:04:46,140
da un problema sistematico, un momento nel quale cioè il gioco diventa ingiocabile e

55
00:04:46,140 --> 00:04:50,940
che si verifica anche più o meno sempre nello stesso punto del gameplay.

56
00:04:50,940 --> 00:04:55,860
Non è sufficiente quindi che il gioco vada in Crash Una Tantum, ma è necessario che

57
00:04:55,860 --> 00:05:02,180
il blocco avvenga in modo più o meno deterministico ogni volta che si raggiungono precisi punti

58
00:05:02,180 --> 00:05:03,740
di avanzamento della partita.

59
00:05:03,740 --> 00:05:09,860
Solitamente, infatti, la causa di questi eventi è dovuta ad un errore di programmazione o

60
00:05:09,860 --> 00:05:15,100
un limite tecnico dell'hardware su cui gira il software, e ciò fa sì che il problema

61
00:05:15,100 --> 00:05:21,380
si verifichi quando vengono soddisfatte determinate condizioni come il raggiungimento di un certo

62
00:05:21,380 --> 00:05:24,460
livello o un certo punteggio o tempo di gioco.

63
00:05:24,460 --> 00:05:30,180
Nel caso specifico di Tetris, il kill screen è considerato il momento in cui il gioco va

64
00:05:30,180 --> 00:05:35,340
totalmente in crash con audio e video che si bloccano, rendendo ovviamente impossibile

65
00:05:35,340 --> 00:05:36,580
proseguire la partita.

66
00:05:36,580 --> 00:05:42,680
Tale evento è causato dal fatto che, arrivati ad un certo punto, il calcolo del punteggio

67
00:05:42,680 --> 00:05:48,020
richiede così tanto tempo che il sistema non riesce a mantenere il passo con l'avanzamento

68
00:05:48,020 --> 00:05:50,100
del gioco e il software va in tilt.

69
00:05:55,100 --> 00:05:59,700
Per capire il motivo per il quale il gioco va in crash dobbiamo ragionare un po' su come

70
00:05:59,700 --> 00:06:05,940
funzionano la Nintendo e Tetris, e in particolare dobbiamo partire dallo studiare come funziona

71
00:06:05,940 --> 00:06:07,700
l'assegnazione del punteggio.

72
00:06:07,700 --> 00:06:13,380
Il gioco assegna dei punti ad ogni clear, cioè ogni volta che si fanno sparire una o

73
00:06:13,380 --> 00:06:14,380
più linee.

74
00:06:14,380 --> 00:06:15,380
È presente, no?

75
00:06:15,380 --> 00:06:20,620
Si fa in modo che i pezzi vadano a comporre delle linee orizzontali complete e queste

76
00:06:20,620 --> 00:06:22,420
immediatamente vengono distrutte.

77
00:06:22,940 --> 00:06:29,460
Una clear singola, cioè di una sola linea, vale di base 40 punti, una doppia 100, una

78
00:06:29,460 --> 00:06:34,260
tripla 300 e una Tetris, cioè una quadrupla, 1200.

79
00:06:34,260 --> 00:06:39,340
Il punteggio di base della clear viene poi moltiplicato per il numero del livello a cui

80
00:06:39,340 --> 00:06:41,420
si sta giocando più uno.

81
00:06:41,420 --> 00:06:48,420
Quindi, se ad esempio effettuiamo una clear tripla a livello 10, otteniamo 3300 punti,

82
00:06:48,420 --> 00:06:52,740
cioè 300 di base moltiplicato per 11, il livello più uno.

83
00:06:52,740 --> 00:06:59,980
Se invece effettuiamo una singola a livello 99, otteniamo 4000 punti, cioè 40 moltiplicato

84
00:06:59,980 --> 00:07:00,980
100.

85
00:07:00,980 --> 00:07:07,060
Questa semplice informazione è molto importante per noi perché ci fa capire che ad ogni assegnazione

86
00:07:07,060 --> 00:07:13,220
di punteggio la NES deve effettuare tutta una serie di calcoli e soprattutto che questi

87
00:07:13,220 --> 00:07:16,820
aumentano di complessità mano a mano che il gioco va avanti.

88
00:07:17,220 --> 00:07:21,820
Poiché infatti il processore della console esegue le operazioni di moltiplicazione in

89
00:07:21,820 --> 00:07:27,140
forma di somme, maggiori sono i numeri da moltiplicare, maggiore sarà anche il numero

90
00:07:27,140 --> 00:07:28,980
di operazioni da effettuare.

91
00:07:28,980 --> 00:07:35,580
In altre parole, quando è necessario calcolare il risultato di 40 moltiplicato 100, quello

92
00:07:35,580 --> 00:07:41,300
che in effetti il processore va ad effettuare è la somma di 40 più 40 più 40 più 40

93
00:07:41,300 --> 00:07:42,900
e così via per 100 volte.

94
00:07:43,340 --> 00:07:49,260
In pratica ciò significa che con l'aumentare del livello di gioco aumenta anche il tempo

95
00:07:49,260 --> 00:07:54,860
necessario per calcolare il punteggio ed è questo fatto che risulta essere poi il fulcro

96
00:07:54,860 --> 00:07:57,140
del problema che conduce al killscreen.

97
00:07:57,140 --> 00:08:05,060
Nella Nintendo infatti lavorano in collaborazione due processori, uno serve per i calcoli matematici,

98
00:08:05,060 --> 00:08:10,500
la gestione degli eventi, degli input eccetera, e l'altro è adibito alla sola visualizzazione

99
00:08:10,500 --> 00:08:11,940
dei frame sullo schermo.

100
00:08:11,940 --> 00:08:18,340
Un po' come le moderne schede video, la Picture Processor Unit, questo è il nome del secondo

101
00:08:18,340 --> 00:08:24,060
processore, ha una sua RAM nella quale compone le immagini e successivamente le invia allo

102
00:08:24,060 --> 00:08:25,060
schermo.

103
00:08:25,060 --> 00:08:33,100
Per fare il suo lavoro però la PPU ha bisogno che il primo processore le produca le informazioni

104
00:08:33,100 --> 00:08:38,820
che deve rendere in forma grafica, ad esempio il valore del punteggio, la posizione del tetramino

105
00:08:38,820 --> 00:08:42,660
che sta accadendo, l'elenco dei prossimi tetramini e così via.

106
00:08:42,660 --> 00:08:49,620
Ciò significa che ad ogni frame il processore principale deve necessariamente produrre tutti

107
00:08:49,620 --> 00:08:56,140
i dati utili alla PPU per disegnare il frame successivo, e poco importa se sta svolgendo

108
00:08:56,140 --> 00:08:57,340
altre mansioni.

109
00:08:57,340 --> 00:09:03,260
In ogni caso è programmato per mettere in pausa qualsiasi altra operazione e dedicarsi

110
00:09:03,260 --> 00:09:05,060
al compito più urgente.

111
00:09:05,460 --> 00:09:11,540
Capiamoci, si tratta di una strategia questa piuttosto condivisibile e in generale conveniente

112
00:09:11,540 --> 00:09:17,140
per sfruttare al meglio l'hardware della console, tuttavia in determinate condizioni risulta

113
00:09:17,140 --> 00:09:18,940
essere fatale per Tetris.

114
00:09:18,940 --> 00:09:25,620
Il problema sta nel fatto che a partire dal livello 155 il calcolo del punteggio di una

115
00:09:25,620 --> 00:09:32,460
singola clear, per come lo abbiamo descritto prima, necessita di ben 156 somme, una quantità

116
00:09:32,460 --> 00:09:37,820
di operazioni tale da richiedere più tempo di quello a disposizione tra un frame e l'altro.

117
00:09:37,820 --> 00:09:43,580
In questa situazione al processore matematico non resta che mettere in pausa i calcoli per

118
00:09:43,580 --> 00:09:49,020
riprenderli al successivo intervallo fra frame ed è qui che viene aperta la strada ad un

119
00:09:49,020 --> 00:09:50,020
possibile crash.

120
00:09:50,020 --> 00:09:55,780
Prima di interrompere i calcoli, infatti, è necessario archiviare nella memoria RAM

121
00:09:55,780 --> 00:09:59,100
i dati utili a riprendere il processo in un secondo momento.

122
00:09:59,540 --> 00:10:05,100
Così facendo, il processore potrà sospendere il proprio lavoro attuale e dedicarsi al calcolo

123
00:10:05,100 --> 00:10:10,540
delle informazioni per il frame, avendo la certezza che una volta finito potrà riprendere

124
00:10:10,540 --> 00:10:12,740
esattamente da dove si era interrotto.

125
00:10:12,740 --> 00:10:18,420
Il problema, però, è che a volte in questo processo può capitare che le operazioni necessarie

126
00:10:18,420 --> 00:10:24,940
a produrre i dati per il nuovo frame accidentalmente causino la sovrascrittura dei dati sul punteggio

127
00:10:24,940 --> 00:10:27,740
in fase di calcolo archiviati nella RAM.

128
00:10:27,900 --> 00:10:33,260
In parole semplici, al momento dell'interruzione, il processore prende una sorta di appunti

129
00:10:33,260 --> 00:10:38,860
sui calcoli in corso per il punteggio, tuttavia, l'area di memoria in cui questi sono salvati

130
00:10:38,860 --> 00:10:44,180
non è in alcun modo protetta ed è quindi esposta a qualsiasi potenziale modifica.

131
00:10:44,180 --> 00:10:49,660
Dunque, potrebbe capitare che, per sbaglio, il processore stesso vi scriva all'interno

132
00:10:49,660 --> 00:10:54,940
delle nuove informazioni perché nel progettare il frame casualmente finisce per utilizzare

133
00:10:54,940 --> 00:10:56,740
le stesse aree di memoria.

134
00:10:56,940 --> 00:11:02,380
Quando un evento del genere si verifica, esso porta con buona probabilità al killscreen.

135
00:11:02,380 --> 00:11:08,780
Devi sapere, infatti, che la console è ottimizzata per sfruttare al massimo il proprio hardware

136
00:11:08,780 --> 00:11:14,180
e, tra le varie strategie di ottimizzazione, implementa anche l'accesso diretto ai byte

137
00:11:14,180 --> 00:11:18,260
della RAM, sia per scrivere che per leggere i dati in esso archiviati.

138
00:11:18,260 --> 00:11:24,060
Quindi, ciò significa che, quando una volta inviato il frame alla TV, il processore va

139
00:11:24,060 --> 00:11:29,340
a recuperare le informazioni che gli servono per completare i calcoli sul punteggio le

140
00:11:29,340 --> 00:11:34,020
legge direttamente dalla RAM senza effettuare alcun controllo sulla loro coerenza.

141
00:11:34,020 --> 00:11:39,860
Così facendo, però, non può in alcun modo rendersi conto del fatto che, accidentalmente,

142
00:11:39,860 --> 00:11:41,740
potrebbero essere stati sovrascritti.

143
00:11:41,740 --> 00:11:44,300
Semplicemente li prende e li usa.

144
00:11:44,300 --> 00:11:49,100
Non è contemplata in alcun modo la possibilità che le informazioni in quei byte possano essere

145
00:11:49,100 --> 00:11:50,100
corrotte.

146
00:11:50,140 --> 00:11:53,180
Ed è qui che si può verificare il killscreen.

147
00:11:53,180 --> 00:11:58,020
Se i dati sono cambiati, possono non essere più coerenti o addirittura possono essere

148
00:11:58,020 --> 00:12:02,900
diventati uno dei vari comandi di chiusura, che in gergo si chiamano stopopcode.

149
00:12:02,900 --> 00:12:08,180
Non esiste un modo per capire che qualcosa è andato storto, perché in quella porzione

150
00:12:08,180 --> 00:12:13,140
di memoria è lecito trovare uno stopopcode, ad esempio nel momento in cui l'utente decide

151
00:12:13,140 --> 00:12:14,460
di uscire dal gioco.

152
00:12:14,460 --> 00:12:19,660
E così, semplicemente, il gioco non fa altro che rispettare i comandi che ha letto dalla

153
00:12:19,660 --> 00:12:25,980
RAM e ferma sia audio che video, bloccandosi così completamente e dando origine al killscreen.

154
00:12:25,980 --> 00:12:31,580
In tutto questo, la beffa è che, chiaramente, chi ha sviluppato il software ha commesso

155
00:12:31,580 --> 00:12:36,460
un grossolano errore di programmazione, e non tanto perché il gioco crasha, quello

156
00:12:36,460 --> 00:12:37,460
può capitare.

157
00:12:37,460 --> 00:12:39,180
L'errore è molto più banale.

158
00:12:39,180 --> 00:12:45,340
Il punteggio massimo mostrato dall'interfaccia di Tetris, infatti, è di un milione di punti,

159
00:12:45,340 --> 00:12:52,380
anzi, per la precisione, 999999, che tra l'altro si raggiunge abbastanza velocemente

160
00:12:52,380 --> 00:12:54,220
nella prima trentina di livelli.

161
00:12:54,220 --> 00:12:59,380
Il software non può mostrare un valore più alto a schermo, semplicemente perché non c'è

162
00:12:59,380 --> 00:13:00,780
lo spazio nella cornice.

163
00:13:00,780 --> 00:13:06,340
A livello computazionale, però, questo limite è stato implementato in modo un po' ingenuo,

164
00:13:06,340 --> 00:13:14,460
effettuando prima i calcoli e poi riportando il valore al massimo di 999999 in caso il risultato

165
00:13:14,580 --> 00:13:16,180
sia maggiore di tale numero.

166
00:13:16,180 --> 00:13:21,700
In pratica, quindi, ciò che accade è che, arrivato a punteggio massimo, quando il giocatore

167
00:13:21,700 --> 00:13:27,700
ottiene altri punti da una clear, questi vengono calcolati, sommati al totale, e poi la cifra

168
00:13:27,700 --> 00:13:31,460
viene riportata al valore massimo perché in ogni caso non la si può superare.

169
00:13:31,460 --> 00:13:36,540
Con il senno di poi, aggiungere un semplice controllo che evitasse di calcolare nuovi

170
00:13:36,540 --> 00:13:42,060
punti in caso di punteggio massimo già raggiunto probabilmente avrebbe evitato il killscreen

171
00:13:42,060 --> 00:13:45,220
o magari lo avrebbe spostato molto più avanti nel gioco.

172
00:13:45,220 --> 00:13:52,140
Ma, ad ogni modo, le cose stanno come stanno e dunque, a partire dal livello 155, le condizioni

173
00:13:52,140 --> 00:13:54,500
per il killscreen vengono soddisfatte.

174
00:13:54,500 --> 00:13:59,180
Da quel momento in poi è solo questione di tempo perché appaia uno stop-hop code nel

175
00:13:59,180 --> 00:14:00,180
byte giusto.

176
00:14:00,180 --> 00:14:05,300
Nel caso di Willys, ad esempio, il gioco si è bloccato a livello 157.

177
00:14:05,300 --> 00:14:16,380
Capito quindi a che punto si trova la fine di Tetris, potresti ora pensare che semplicemente

178
00:14:16,380 --> 00:14:22,820
basti accendere la Nintendo, prendere il controller e giocare finché non si raggiunge il killscreen,

179
00:14:22,820 --> 00:14:24,500
ma non è proprio così.

180
00:14:24,500 --> 00:14:29,820
Devi sapere che per molti anni si è pensato che l'ultimo livello giocabile di Tetris

181
00:14:29,820 --> 00:14:31,260
fosse il 29.

182
00:14:31,580 --> 00:14:37,940
La velocità di caduta dei tetramini, infatti, aumenta con l'aumentare dei livelli ed in particolare

183
00:14:37,940 --> 00:14:43,380
a livello 29 essi raggiungono la velocità massima che corrisponde a ben una linea per

184
00:14:43,380 --> 00:14:44,380
frame.

185
00:14:44,380 --> 00:14:50,620
E dato che il gioco originale in versione NTSC funziona a 60 frame per secondo, ciò

186
00:14:50,620 --> 00:14:56,660
vuol dire che ogni tetramino si sposta alla velocità di 60 linee per secondo e l'intera

187
00:14:56,660 --> 00:15:02,900
schermata è composta da sole 20 linee, quindi di fatto ogni pezzo arriva sul fondo in un

188
00:15:02,900 --> 00:15:04,020
terzo di secondo.

189
00:15:04,020 --> 00:15:10,300
Chiaramente questa è una velocità notevolmente difficile da gestire perché in effetti bisogna

190
00:15:10,300 --> 00:15:14,620
che il giocatore sappia già dove piazzare il pezzo prima ancora che esso inizi la propria

191
00:15:14,620 --> 00:15:20,400
discesa, perché altrimenti un tempo di reazione umano non sarebbe sufficiente a prendere tale

192
00:15:20,400 --> 00:15:21,400
decisione.

193
00:15:21,600 --> 00:15:26,640
Ma al di là di questo, per molto tempo si è pensato che il problema fosse proprio un

194
00:15:26,640 --> 00:15:33,780
limite tecnico dei joypad Nintendo, perché in un terzo di secondo non c'è tempo per tenere

195
00:15:33,780 --> 00:15:38,880
premuto il tasto destro o sinistro a sufficienza per portare il tetramino all'estremità del

196
00:15:38,880 --> 00:15:39,880
quadro.

197
00:15:39,880 --> 00:15:45,160
Per questo motivo si pensava che giocare a tale velocità fosse impossibile e che il livello

198
00:15:45,160 --> 00:15:50,480
29 fosse quindi il livello corrispondente al kill screen, tant'è vero che quello del

199
00:15:50,480 --> 00:15:56,960
livello 155 viene anche chiamato il true kill screen, il vero kill screen, proprio ad indicare

200
00:15:56,960 --> 00:15:58,320
la differenza tra i due.

201
00:15:58,320 --> 00:16:04,800
Solo da pochi anni, invece, i giocatori professionisti di Tetris hanno iniziato ad utilizzare la tecnica

202
00:16:04,800 --> 00:16:09,080
dell'hypertapping per superare il limite tecnico dei joypad.

203
00:16:09,080 --> 00:16:15,280
A parole, l'hypertapping consiste semplicemente nel premere ripetutamente il tasto del controller

204
00:16:15,280 --> 00:16:20,400
per spostare il tetramino più rapidamente, ma nella pratica non si tratta affatto di una

205
00:16:20,400 --> 00:16:21,400
tecnica banale.

206
00:16:21,400 --> 00:16:26,280
Può essere infatti definito hypertapping solo un movimento che permette di premere

207
00:16:26,280 --> 00:16:32,080
il tasto almeno 10 volte al secondo, e per riuscirci i giocatori sono costretti a effettuare

208
00:16:32,080 --> 00:16:37,680
gesti velocissimi e spesso posizionare il controller nei modi più disparati, come ad

209
00:16:37,680 --> 00:16:39,400
esempio sul petto o sulle gambe.

210
00:16:39,400 --> 00:16:45,360
Ma nonostante questa tecnica abbia permesso di superare il livello 29, l'unico modo per

211
00:16:45,360 --> 00:16:52,960
arrivare al 155 è utilizzare la sua evoluzione, denominata rolling, inventata nel 2022 e

212
00:16:52,960 --> 00:16:56,560
da allora diventata praticamente lo standard tra i professionisti.

213
00:16:56,560 --> 00:17:03,600
Il rolling consiste nel tenere il dito fermo appoggiato sul pulsante invece di usarlo per

214
00:17:03,600 --> 00:17:09,280
premere, e sfruttare poi le dita dell'altra mano per colpire ripetutamente il retro del

215
00:17:09,280 --> 00:17:13,040
controller come se si stesse tamburellando con le dita su un tavolo.

216
00:17:13,440 --> 00:17:19,080
In questo modo, la vibrazione prodotta dalle quattro dita che lo colpiscono dal di sotto

217
00:17:19,080 --> 00:17:25,040
spinge il controller e quindi il tasto contro il dito del giocatore e gli permette di eseguire

218
00:17:25,040 --> 00:17:29,960
spostamenti in una sequenza rapidissima e controllata senza sforzi eccessivi.

219
00:17:29,960 --> 00:17:35,040
Il rumore che si sente nel video di Willis e di cui ti ho parlato all'inizio di questo

220
00:17:35,040 --> 00:17:40,240
episodio è proprio causato dalle sue dita che urtano il controller mentre utilizza

221
00:17:40,240 --> 00:17:41,920
la tecnica del rolling.

222
00:17:44,040 --> 00:17:52,680
Come se le difficoltà fino ad ora illustrate non bastassero poi, arrivati al livello 138

223
00:17:52,680 --> 00:17:56,160
si presenta un ulteriore problema, il glitch dei colori.

224
00:17:56,160 --> 00:18:01,960
In Tetris, i colori dei tetramini cambiano di livello in livello seguendo uno schema

225
00:18:01,960 --> 00:18:05,400
ben definito composto da 10 palette che si ripetono.

226
00:18:05,400 --> 00:18:11,760
A livello software, il gioco mantiene in memoria una tabella contenente le 10 palette di colori

227
00:18:11,760 --> 00:18:16,120
in un vettore di 10 posizioni, i cui indici vanno da 0 a 9.

228
00:18:16,120 --> 00:18:22,040
Ad ogni cambio di livello poi un algoritmo effettua un semplice calcolo sottraendo ripetutamente

229
00:18:22,040 --> 00:18:27,440
il valore 10 al numero del livello finché non ottiene un risultato compreso tra 0 e 9.

230
00:18:27,440 --> 00:18:29,840
Quello è il numero della palette da usare.

231
00:18:29,840 --> 00:18:37,120
Per capire quando ha sottratto abbastanza volte 10, l'algoritmo controlla se il risultato

232
00:18:37,120 --> 00:18:39,120
dell'operazione è negativo.

233
00:18:39,480 --> 00:18:43,960
In caso affermativo decide che il precedente valore è quello da scegliere.

234
00:18:43,960 --> 00:18:51,320
Quindi, se stiamo giocando a livello 29 ad esempio, il sistema sottrae 10 e ottiene 19,

235
00:18:51,320 --> 00:18:56,280
poi sottrae 10 e ottiene 9, poi sottrae ancora 10 e ottiene meno 1.

236
00:18:56,280 --> 00:19:02,360
Meno 1 è negativo, quindi il valore precedente, cioè 9, è quello da scegliere nella tabella

237
00:19:02,360 --> 00:19:03,360
dei colori.

238
00:19:03,360 --> 00:19:08,560
Il problema qui sta nel fatto che il risultato di questo calcolo viene archiviato in memoria

239
00:19:08,560 --> 00:19:13,860
in un singolo byte e, siccome parliamo di un numero che può essere sia positivo che

240
00:19:13,860 --> 00:19:21,240
negativo, tale byte può contenere al massimo i valori che vanno da meno 128 a più 127.

241
00:19:21,240 --> 00:19:27,600
Questo intervallo di numeri è determinato dal fatto che un byte è composto da 8 bit

242
00:19:27,600 --> 00:19:33,160
e per rappresentare un numero intero dotato di segno, il primo bit viene utilizzato per

243
00:19:33,160 --> 00:19:37,640
rappresentare appunto il segno, cioè il più e il meno e gli altri 7 per le cifre.

244
00:19:37,720 --> 00:19:44,400
In una tale condizione, arrivati nel gioco al livello 138, il valore risultante dalla

245
00:19:44,400 --> 00:19:52,400
differenza di 138-10 è uguale a 128, ma in un byte singolo la rappresentazione in bit

246
00:19:52,400 --> 00:19:56,600
di 128 è esattamente identica a quella di 127.

247
00:19:56,600 --> 00:20:04,520
Per questo motivo la console crede che la sottrazione di 138-10 produca un risultato negativo pari

248
00:20:04,520 --> 00:20:11,240
a 127 e quindi, secondo l'algoritmo per la scelta della posizione in tabella descritto

249
00:20:11,240 --> 00:20:18,080
prima, è giusto scegliere come indice l'ultimo intero positivo precedente, cioè 138, ma

250
00:20:18,080 --> 00:20:23,520
in una tabella che va da 0 a 9 la posizione 138 ovviamente non esiste.

251
00:20:23,520 --> 00:20:28,520
Ciò che accade quindi è che viene selezionata per la scelta dei colori un'area di memoria

252
00:20:28,520 --> 00:20:34,120
adibita a tutt'altro compito e la conseguenza è che i valori utilizzati per i colori sono

253
00:20:34,120 --> 00:20:37,520
totalmente sbagliati, sono dati che servono ad altro.

254
00:20:37,520 --> 00:20:43,360
Per via di questo errore, quindi, a partire dal livello 138 i tetramini diventano di colori

255
00:20:43,360 --> 00:20:48,440
inusuali, che non sarebbe neanche un problema se non fosse che in alcuni casi essi sono

256
00:20:48,440 --> 00:20:51,440
così scuri da essere quasi invisibili a schermo.

257
00:20:51,440 --> 00:20:57,800
In particolare, il livello più problematico in assoluto in questo senso è il 148, che

258
00:20:57,800 --> 00:21:02,440
è stato addirittura soprannominato carbone proprio per via del fatto che i tetramini

259
00:21:02,440 --> 00:21:07,480
sono così scuri da essere quasi neri come lo sfondo della schermata di gioco.

260
00:21:07,480 --> 00:21:17,440
Bene, spero di averti raccontato anche oggi qualcosa di interessante, quando ho scoperto

261
00:21:17,440 --> 00:21:21,920
tutti questi dettagli su Tetris io sono rimasto particolarmente colpito.

262
00:21:21,920 --> 00:21:25,040
Prima di chiudere però un paio di avvisi importanti.

263
00:21:25,040 --> 00:21:31,240
Innanzitutto Google Podcast chiude, se lo utilizzi dovresti già saperlo, ma ripeterlo

264
00:21:31,240 --> 00:21:36,320
non fa mai male, in ogni caso ti consiglio di passare ad un'app di podcast più moderna

265
00:21:36,320 --> 00:21:40,720
e completa, che magari supporti le funzionalità del Podcasting 2.0.

266
00:21:40,720 --> 00:21:47,120
E a proposito di Podcasting 2.0 ti ricordo poi che Pensieri in Codice aderisce alla filosofia

267
00:21:47,120 --> 00:21:52,840
Value for Value, il che vuol dire che io mi impegno a produrre episodi interessanti,

268
00:21:52,840 --> 00:21:59,120
gratuiti e liberi da pubblicità e in cambio tu, ascoltatore o ascoltatrice restituisci

269
00:21:59,120 --> 00:22:05,000
un po' del valore che ricevi attraverso una delle tre T, Time, Talent o Treasure.

270
00:22:05,000 --> 00:22:10,520
In parole povere valuta quanto vale per te questo progetto, quanto ti dispiacerebbe se

271
00:22:10,520 --> 00:22:17,240
non esistesse e poi scegli se restituire un po' di questo valore nella forma che preferisci,

272
00:22:17,240 --> 00:22:21,840
impiegando un po' del tuo tempo, condividendo gli episodi, portando nuovi ascoltatori o

273
00:22:21,840 --> 00:22:24,880
lasciando una recensione su Apple Podcast ad esempio.

274
00:22:25,320 --> 00:22:30,080
Impiegando il tuo talento, ci sono tante cose che potrebbero servire, dalla gestione

275
00:22:30,080 --> 00:22:35,200
dei social allo sviluppo di qualche parte del sito, dei servizi di automazione alla

276
00:22:35,200 --> 00:22:39,520
scrittura di episodi o qualsiasi cosa che puoi proporre anche tu direttamente.

277
00:22:39,520 --> 00:22:45,520
O infine, ma veramente come ultima spiaggia, impiegando il tuo tesoro, cioè i tuoi soldi,

278
00:22:45,520 --> 00:22:47,440
quindi facendo una piccola donazione.

279
00:22:47,440 --> 00:22:53,560
In tutti i casi io ti ringrazio e trovi le informazioni sul sito pensieriincodice.it

280
00:22:53,560 --> 00:22:54,840
o nel gruppo Telegram.

281
00:22:54,840 --> 00:23:00,280
Oggi un ringraziamento speciale va a Guelf Alexander per la sua super donazione, a Edoardo

282
00:23:00,280 --> 00:23:05,160
e Carlo per la loro donazione mensile, ad Antonio per aver realizzato e migliorato lo

283
00:23:05,160 --> 00:23:11,000
script di condivisione delle news nel gruppo Telegram e a Francesco per la locandina dell'episodio.

284
00:23:11,000 --> 00:23:15,800
E a proposito, da qualche tempo nel gruppo Telegram sto anche condividendo un bel po'

285
00:23:15,800 --> 00:23:21,360
di articoli interessanti che leggo ogni giorno, che è un altro buon motivo per unirsi, no?

286
00:23:21,360 --> 00:23:26,960
E basta così, spero di non dimenticare niente e nessuno, noi ci sentiamo al prossimo episodio

287
00:23:26,960 --> 00:23:32,080
ricordando sempre che un informatico risolve problemi, a volte, anche usando il computer.
